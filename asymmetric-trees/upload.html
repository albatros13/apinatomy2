<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Populate lyph template repository</title>
    <script src="js/lib/jquery.js"></script>
    <script src="js/lib/rsvp.js"></script>
</head>
<body>
    <script src="js/scripts/apinatomy2.js"></script>

    <script>
        var nodes = {};
        var nodeAnnotations = {};
        var links = [];
        var cocomacLinks = [];

        cocomacFMA = {};
        fmaCocomac = {};

        var lyphRepo = new ApiNATOMY2.LyphTemplateRepo([]);

        /*
        lyphRepo.load("http://open-physiology.org:8889")
           .then(function(){
               loadBrainNodes();
               loadBrainLinks();
               loadCocomacFMA();
           });
        */

        //loadBrainLinks();
        loadCocomacFMA();

        function testLyphChildren(){
            var i = 0;
            lyphRepo.items.forEach(function(lyph){
                if (lyph.fmaID && lyph.children && lyph.children.length > 0){
                   console.dir("Lyph # " + lyph.id + " (" + lyph.fmaID + ") " + printList(lyph.children));
                    i++;
                }
            });
            console.dir("Total: " + i);
        }

        function printList(array){
            var str = "";
            for (var i = 0; i < array.length; i++)
                str += array[i] + ((i < array.length - 1)? ",": "");
            return str;
        }

        //***********************************
        //Brain FMA
        //***********************************
        function loadBrainNodes(){
            var file = "resources/AE_Brain_FMA_unique.txt";
            $.ajax({
                url: file,
                success: function(data) {
                    var lines = data.split('\n');
                    for(var i = 0; i < lines.length; i++){
                        var id = lines[i];
                        nodes[id] = {id: id};
                    }
                    //loadBrainNodeAnnotations();
                }
            });
        }

        function loadBrainNodeAnnotations(){
            var file = "resources/fmaNames.txt";
            $.ajax({
                url: file,
                success: function(data) {
                    var lines = data.split('\n');
                    for(var i = 0; i < lines.length; i++){
                        var line = lines[i];
                        var endOfURI = line.indexOf(' ');
                        if (endOfURI > -1){
                            var URI = line.substring(0, endOfURI);
                            var id = ApiNATOMY2.Utils.extractID(line.substring(0, endOfURI));
                            nodeAnnotations[id] = {label: line.substring(endOfURI + 1), URI: URI}
                        }
                    }
                    //addBrainFMALyphsToRepo();
                }
            });
        }

        function loadBrainLinks(){
            var file = "resources/fmaBrainGraph.txt";
            $.ajax({
                url: file,
                success: function(data) {
                    var lines = data.split('\n');
                    for(var i = 0; i < lines.length; i++){
                        var line = lines[i];
                        var terms = line.split(' ');
                        if (terms.length >= 3){
                            var linkType = terms[0].trim();
                            if (linkType == "Part"){
                                var link = {source: terms[1].trim(), target: terms[2].trim(), type: linkType};
                                links.push(link);
                            }
                        }
                    }
                    //addLyphPartonomyRelations();
                    //printBrainPartonomyGraph();
                    //printBrainNodes();
                    //selectPartonomyNodes;
                }
            });
        }

        function selectPartonomyNodes(){
            nodes = {};
            links.forEach(function(link){
                if (!nodes[link.source]) nodes[link.source] = {id: link.source};
                if (!nodes[link.target]) nodes[link.target] = {id: link.target};
            });
            //loadCocomacFMA();
        }

        //************************************
        //Creating partonomy graph for SMT
        //************************************
        function printBrainPartonomyGraph(){
            links.forEach(function(link){
                console.dir(link.source + "," + link.target + ",PARTONOMY");
            });
        }

        function printBrainNodes(){
            nodes = {};
            links.forEach(function(link){
                if (!nodes[link.source]) nodes[link.source] = {id: link.source};
                if (!nodes[link.target]) nodes[link.target] = {id: link.target};
            });
            for (var key in nodes){
                console.dir(nodes[key].id + ",REGION");
            }
        }

        function saveTextAsFile(textToWrite){
            var textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});
            var fileNameToSaveAs = "output.txt";
            var downloadLink = document.createElement("a");
            downloadLink.download = fileNameToSaveAs;
            downloadLink.innerHTML = "Download File";
            if (window.webkitURL != null)
                downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
            downloadLink.click();
        }

        //************************************
        //Updating LyphRepo
        //************************************

        function addBrainFMALyphsToRepo(){
            console.dir("Number of lyphs before: " + lyphRepo.items.length);
            var i = 0;
            for (var key in nodes){
                var node = nodes[key];
                var existing = lyphRepo.getItemsByOntologyID(node.id);
                if (!existing || existing.length == 0){
                    var newObj = lyphRepo.defaultObject();
                    lyphRepo.add(newObj);
                    //update (new)
                    newObj.fmaID = node.id;
                    if (nodeAnnotations[node.id])
                        newObj.name = nodeAnnotations[node.id].label;
                    newObj.status = "new";
                    //console.dir("Lyph template added: " + node.id);

                    //var delay = 500 * i++; //0.5 second
                    //setTimeout(function() {
                    //    newObj.commit(lyphRepo.url);
                    //}, delay);
                }
                //else console.dir("Lyph template already exists: " + node.id);
                else {
                    if (existing.length > 0)
                        console.dir("Added twice: " + node.id);
                    if (existing[0].name == "")
                        console.dir("No name: " + node.id);

                }
            }
            console.dir("Number of lyphs after: " + lyphRepo.items.length);
            //lyphRepo.commit();
        }

        function addLyphPartonomyRelations(){
            console.dir("Number of relations: " + links.length);
            var i = 0;
            links.forEach(function(link){
                var sourceSet = lyphRepo.getItemsByOntologyID(link.source);
                var targetSet = lyphRepo.getItemsByOntologyID(link.target);

                if (sourceSet && targetSet){
                    sourceSet.forEach(function(source){
                        if (!source.children) source.children = [];
                        targetSet.forEach(function(target){
                            if (!source.children) source.children = [];
                            if (source.children.indexOf(target) < 0){
                                source.children.push(target.id);
                                source.status = "updated";
                                console.dir(source.fmaID + " - " + target.fmaID);

                                var delay = 500 * i++; //0.5 second
                                setTimeout(function() {
                                    source.commit(lyphRepo.url);
                                }, delay);
                            }
                        });
                    });
                }
                else {
                    console.dir("Pair is going to be skipped: " + link.source + " - " + link.target);
                }
            });
        }

        //************************************
        //Loading Cocomac & updating LyphRepo
        //************************************

        function loadCocomacFMA(){
            //var file = "resources/upload/coco_to_fma_map_unique.txt";
            var file = "resources/upload/coco_uber_match_v2.txt";
            $.ajax({
                url: file,
                success: function(data) {
                    var lines = data.split('|');
                    var skipped = 0;
                    console.dir(lines);
                    for(var i = 0; i < lines.length; i++){
                        var terms = lines[i].split(",");
                        var cocomacID = terms[0].trim();
                        var fmaID = terms[1].trim();
                        if (terms.length >=3){
                            var fma2 = terms[2]; //skip pairs
                            skipped++;
                        }
                        else{
                            if (!cocomacFMA[fmaID]) cocomacFMA[fmaID] = [];
                            if (cocomacFMA[fmaID].indexOf(cocomacID) < 0)
                                cocomacFMA[fmaID].push(cocomacID);

                            if (!fmaCocomac[cocomacID]) fmaCocomac[cocomacID] = [];
                            if (fmaCocomac[cocomacID].indexOf(fmaID) < 0)
                                fmaCocomac[cocomacID].push(fmaID);
                        }
                    }
                    //updateLyphsWithCocomacIDs();
                    //console.dir(cocomacFMA);
                    //console.dir(fmaCocomac);
                    loadBrainConnectivityLinks();
                }
            });
        }

        function loadBrainConnectivityLinks(){
            var file = "resources/upload/cocomac_connectivity_v4.txt";
            $.ajax({
                url: file,
                success: function(data) {
                    var lines = data.split('\n');
                    for(var i = 0; i < lines.length; i++){
                        var line = lines[i];
                        var terms = line.split(',');
                        if (terms.length >= 2){
                            var link = {source: terms[0].trim(), target: terms[1].trim()};
                            cocomacLinks.push(link);
                        }
                    }
                    //console.dir(links);
                    printBrainConnectivityGraph();
                }
            });
        }

        function printBrainConnectivityGraph(){
            var printContents = "";
            cocomacLinks.forEach(function(link){
                var sourceFMA = fmaCocomac[link.source];
                var targetFMA = fmaCocomac[link.target];
                if (sourceFMA && targetFMA){
                    sourceFMA.forEach(function(source){
                        targetFMA.forEach(function(target) {
                            var connectivityLink = source + "," + target + ",CONNECTIVITY";
                            //console.dir(connectivityLink);
                            printContents += connectivityLink + "\n";
                        });
                    });
                }
            });
            saveTextAsFile(printContents);
        }

        function updateLyphsWithCocomacIDs(){
            var i = 0;
            for (var fmaID in cocomacFMA){
                var lyphSet = lyphRepo.getItemsByOntologyID(fmaID);
                if (lyphSet){
                    lyphSet.forEach(function(lyph){
                        if (cocomacFMA[fmaID] && cocomacFMA[fmaID].length > 0){
                            lyph.cocomacIDs = cocomacFMA[fmaID];
                            lyph.status = "updated";
                            //console.dir("Updated: " + lyph.fmaID + ": " + lyph.cocomacIDs.length);

                            /*
                            var delay = 500 * i++; //0.5 second
                            setTimeout(function() {
                                lyph.commit(lyphRepo.url);
                            }, delay);*/
                        }
                    })
                }
            }
        }
    </script>

</body>
</html>